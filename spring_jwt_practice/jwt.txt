 앱에서 로그아웃을 하지 않는 이상 로그인을 유지하기위해 jwt사용. 
 일반적으로는 Session을 이용해서 클라이언트와 서버 통신 중 Stateless 무상태의 단점을 보완할 수 있었지만, 모바일의 특성상 자주 끊길 소지가 있음 
 
JSON Web Token(JWT)은 JSON 객체로서 당사자 간에 안전하게 정보를 전송할 수 있는 작고 독립적인 방법을 정의하는 공개 표준 (RFC 7519) 
JWT는 Claim based Token(사용자에 대한 프로퍼티/속성) 이다.
서버와 클라이언트 사이에서 JSON 객체를 이용해 Self-contained(토큰자체가 정보/ key,value) 방식으로 정보를 안전한게 전달
회원 인증, 정보 전달에 주로 사용

JWT는 암호 (HMAC 알고리즘 사용) 또는 RSA를 사용하는 공용 /개인 키 쌍을 사용하여 서명을 할 수 있다
그러나 대표적인 취약점은 발행된 토큰을 제거할 수 없다.(기간 만료 제외) 이러한 이유 때문에 Blacklist(DB)를 만들어 관리. 로그아웃시 jwt를 blacklist라는 db테이블에 넣어 해당토큰의 이용을 막는다

일반적으로 모바일 애플리케이션과 백엔드 간 인증은 JWT을 이용하여 수행
별도의 로그인 end point 를 만들고 로그인을 수행해야 하니 기본적으로 아이디와 비밀번호를 앱에서 서버로 보내야함
전달받은 아이디와 비밀번호를 이용하여 로그인 성공 또는 실패를 구현하고, 로그인 성공시 JWT 토큰을 서버에서 생성하여 클라이언트로 보냄
일반적으로 JWT 토큰 생성시 사용자 식별 정보와 토큰의 만료시간이 포함됨
로그인 성공 후에 서버로부터 전달받은 JWT 를 앱에서 보관, 이후 권한이 필요한 백엔드 API 호출시 JWT 토큰을 첨부하여 서버에 전달

JWT 인증을 이용한 게시글 작성 API 호출 시나리오
1.앱 실행
2.로그인 수행
3.앱에서 서버로 로그인정보를 전송 후 로그인 성공시 서버로부터 생성되어 전달받은 JWT 토큰을 클라이언트에 보관
4.게시글 작성화면 진입
5.게시글 작성에 필요한 데이터와 로그인 성공시 전달받은 JWT 토큰을 서버에 함께 전송
6.서버에서는 JWT 토큰을 검증 (유효한 토큰인지 -> 유효시간 및 사용자 유효성 체크) 하여 성공시 게시글 작성 및 응답

JWT 토큰을 전달하는 두가지 방법
1.RequestHeader 에 토큰을 담아 서버로 전달
어플리케이션(안드로이드) ---RequestHeader--> 서버
                  <--ResponseHeader--

2.End point url 파라미터에 토큰을 담아 서버로 전달

인증이 필요한 API 호출시에도 크게 2가지 스타일로 구현
1. Retrofit 의 Interceptor 를 구현하여 인증이 필요한 API 요청마다 JWT 토큰을 요청 헤더에 포함하여 전달
2. Retrofit Rest Api 를 수행하는 별도의 Executor 클래스를 작성하여 인증이 필요한 API 호출시에 토큰을 포함하여 전달 (URL 파라미터 이용)

서버측에서도 여러가지 방법이 있으나, 스프링을 이용하여 JWT 토큰 관련 처리를 수행할 때는 Filter 를 등록하여 처리
1.인증이 필요한 API 분류
2.해당 API 호출시 요청 헤더에 JWT 토큰이 존재하는지 확인
3.인증 후 처리

JWT의 기본구조
Header . Payload . Signature

1. Header
JWT 웹 토큰의 헤더 정보

typ : 토큰의 타입, JWT만 존재
alg : 해싱 알고리즘. (HMAC SHA256 or RSA). 헤더를 암호화 하는게 아니다. 토큰 검증시 사용.
{
     "typ" : "JWT"
     "alg" : "HS256",
}


2. Payload
실제 토큰으로 사용하려는 데이터가 담기는 부분. 각 데이터를 Claim이라고 함

iss (String) : issuer, 토큰 발행자 정보
exp (Number) : expiration time, 만료일
sub (String) : subject, 제목
aud (String) : audience, 토큰대상자
+
nbf: Not Before 를 의미하며, 토큰의 활성 날짜와 비슷한 개념입니다. 여기에도 NumericDate 형식으로 날짜를 지정하며, 이 날짜가 지나기 전까지는 토큰이 처리되지 않습니다.
iat: 토큰이 발급된 시간 (issued at), 이 값을 사용하여 토큰의 age 가 얼마나 되었는지 판단 할 수 있습니다.
jti: .setId(String jti) - JWT의 고유 식별자로서, 주로 중복적인 처리를 방지하기 위하여 사용됩니다. 일회용 토큰에 사용하면 유용합니다.


Public claims : 사용자 정의 Claim. 
Public 이라는 이름처럼 공개용 정보
충돌 방지를 위해 URI 포맷을 이용해 저장한다.

Private claims : 사용자 정의 Claim
Public claims 과 다르게 사용자가 임의로 정한 정보


3. Signature
Header 와 Payload의 데이터 무결성과 변조 방지를 위한 서명 
Header + Payload 를 합친 후, Secret 키와 함께 Header의 해싱 알고리즘으로 인코딩

HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)


JWT 구조
JWT는 [Header Payload Signature] 각각 JSON 형태의 데이터를 base 64 인코딩 후 합침
최종적으로 만들어진 토큰은 HTTP 통신 간 이용되며, Authorization 이라는 key의 value로서 사용됨
아래와 같은 순서로 . 을 이용해 합침
header.payload.signature

JWT인증과정
1. Client가 Server에 POST 방식으로 로그인. (GET으로 로그인시 회원정보가 url에 노출되는 위험성이있음)
2. Server에서 시크릿키와함께 토큰을생성
3. Server에서 Client로 토큰을 리턴
4. Client에서 Server로 헤더 토큰과 함께 요청
5. Server에서 토큰 Signature 확인
6. Server에서 Client로 응답

JWT 단점
1. Self-contained : 토큰 자체에 정보가 있다는 사실은 양날의 검이 될수 있음
2. 토큰 길이 : 토큰 자체 payload 에 Claim set을 저장하기 때문에 정보가 많아질수록 토큰의 길이가 늘어나 네트워크에 부하를 줄 수 있음
3. payload 암호화 : payload 자체는 암호화 되지 않고 base64로 인코딩한 데이터 중간에 payload를 탈취하면 디코딩을 통해 테이터를 볼 수 있음 
JWE 를 통해 암호하하거나, payload에 중요 데이터를 넣지 않아야 함

4. Stateless : 무상태성. 토큰은 한번 만들면 서버에서 제어가 불가능. 
토큰을 임의로 삭제할 수 있는 방법이 없기 때문에 토큰 만료시간을 꼭 넣어주는게 좋음.

5. tore Token : 토큰은 클라이언트 side에서 관리해야하기 때문에 토큰을 저장해야함.

* JWT는 보통 쿠키 또는 HTTP의 Authorization 헤더에 담아서 보낸다.
ex) response.setHeader("Authorization", token);

<!-- JWT 디펜던시-->
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt</artifactId>
	<version>0.7.0</version>
</dependency>

* JWT Inspector
JWT Inspector는 크롬 브라우저의 오픈소스 익스텐션으로 개발자가 JWT를 브라우저 내에서 디버그할 수 있도록 도와줍니다.


Claim으로 변환도중 발생하는 에러
1) ExpiredJwtException : JWT를 생성할 때 지정한 유효기간 초과할 때.

2) UnsupportedJwtException : 예상하는 형식과 일치하지 않는 특정 형식이나 구성의 JWT일 때

3) MalformedJwtException : JWT가 올바르게 구성되지 않았을 때

4) SignatureException :  JWT의 기존 서명을 확인하지 못했을 때

5) IllegalArgumentException

6) ClaimJwtException : JWT 권한claim 검사가 실패했을 때

7) PrematureJwtException : 접근이 허용되기 전인 JWT가 수신된 경우


*JWE, JWS, JWT
JWT 규격에 따르면 “JWT는 권한claims 집합을 JWS와 (또는) JWE 구조로 인코드한 JSON 객체로 표현된다”라고 되어 있습니다. 기술적으로 “JWT”는 서명되지 않은 토큰을 의미하지만 일반적인 상황에서는 JWT는 JWS나 JWS+JWE를 의미합니다.

JWS — JSON Web Signature
서버는 JWT를 JWS 체계로 서명해서 시그너처signature와 함께 클라이언트로 전송합니다. 시그너처는 JWT에 포함된 권한claim이 위조되었거나 변경되지 않았다는 것(무결성)을 보장합니다. 즉, JWS를 통해 위변조를 확인할 수 있을 뿐 JWT는 근본적으로 암호화 되지않은 문자열plaintext입니다. 따라서 JWT에 민감한 정보를 저장해서는 안됩니다.

JWE — JSON Web Encryption
반면에 JWE 체계에서는 내용이 서명없이 암호화됩니다. JWT에 암호화를 통한 기밀성은 부여하지만 JWE를 JWS로 서명해서 담는 만큼의 보안성을 제공하지는 못합니다. 즉, JWS+JWE로 안전한 토큰을 만들 수 있습니다.

OAuth
OAuth 2.0은 인증authentication과 허가authorization를 제공하는 서비스와 상호 연동을 하기 위한 프레임워크입니다. 수많은 모바일 및 웹 애플리케이션에 폭 넓게 도입되었습니다. OAuth 2.0에서 토큰의 형태를 규정하고 있지는 않지만 JWT가 사실상의 빠르게 산업 표준이 되어 가고 있습니다.
OAuth의 구조에서는 두 가지 토큰 타입(액세스access 토큰, 리프레쉬refresh 토큰)이 있습니다. 최초의 인증에서 사용자의 애플리케이션은 이 두 가지 토큰을 발급 받습니다. 액세스 토큰은 상대적으로 짧은 시간 이후에 무효화expire되도록 설정되어 있으므로 최초의 액세스 토큰이 무효화되면 리프레쉬refresh 토큰을 사용해서 새로운 토큰을 획득할 수 있습니다. 리프레쉬 토큰에도 유효 기간을 설정expiration을 할 수 있어서 그 시점까지 무제한으로 사용할 수 있습니다. 액세스 토큰과 리프레쉬 토큰 둘다 내장된 보안(서명될 때)을 가지고 있어서 변조를 방지할 수 있으며 특정 기간 동안만 유효합니다.


참고
https://alwayspr.tistory.com/8
